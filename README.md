# 2019_1_DataStructure
본 프로젝트는 2019년도 1학기 자료구조와 실습에서 다룬 프로젝트로 전반적인 자료구조에 대한 이해와 활용능력을 평가하기 위한 ‘프로그램 만들기 프로젝트’로 총 3개의 프로젝트로 구성되어있다.  
1.	List 자료구조를 기반으로 전화번호부 및 생일 검색 프로그램 만들기  
2.	Linked List 자료구조를 기반으로 Micro-FaceBook만들기  
3.	Tree자료구조를 기반으로 조직도 프로그램 만들기  

### 1. List 자료구조를 기반으로 전화번호부 및 생일 검색 프로그램 만들기
이 프로그램의 입출력 방식은 전반적으로 파일입출력 형식이다. 입력으로는 이미 입력되어 있는 전화번호부를 읽어 프로그램에 저장하며 저장된 상태에서 전화번호 추가, 삭제, 생일검색과 같은 추가작업이 가능하다. 출력방식은 txt파일로 현재 저장되어 있는 전화번호들을 전화번호부로 만들어 txt파일로 만드는 작업이 가능하다.  
기본 구현 방식은 배열기반 List 자료구조이다. 기본적인 insert, delete를 하기 위해서 사람의 이름, 전화번호, 생일과 같은 정보들이 필요하다. 여기서 정보들은 공백을 포함할 수 있기 때문에 cin이 아닌 getline으로 입력을 받도록 설계하였다. 포인터 기반이 아니라 배열기반이기 때문에 배열사이즈로 예외처리를 잘 해준다면 전체적인 구현은 쉽게 가능하다.  

### 2. Linked List 자료구조를 기반으로 Micro-FaceBook만들기
이 프로그램은 Micro-FaceBook 만들기지만 사실 이중리스트를 Linked List기반으로 구현하는 것이다.  
전체 기능은 다음과 같다.  
<b>1.	이용자 추가  
2.	A와 B를 친구 설정  
3.	A와 B를 친구 삭제  
4.	A의 친구목록 출력  
5.	A와 B가 친구인지 확인    </b>
해당 프로그램은 두 종류의 노드가 필요하다. 하나는 실제 이용자의 명단을 나타내는 노드이고 다른 하나는 이용자의 친구목록을 나타내기 위한 노드이다. 그렇기 때문에 insert, delete연산이 각각 두종류가 필요하다. 또한 해당 프로그램 구현과정에서 신경 써야 할 점은 바로 여러가지 경우의 예외처리이다. 예를들면, ‘이정석’이라는 이용자를 추가하려는데  이미 존재하는 이용자이거나, A와 B를 친구 설정하려는데 이미 친구인 상태이거나 등 많은 예외상황이 발생하게 된다. 이를 해결하기 위해 전반적으로 ~한 이름을 가진 사용자나, A의 친구목록에서 B가 존재하는지를 알아낼 함수구현이 필요한 상황이고 이는 선형탐색으로 쉽게 구현이 가능하다.

### 3. Tree자료구조를 기반으로 조직도 프로그램 만들기
아 프로그램은 Tree기반으로 다음 사진과 같은 형태로 조직도를 만드는 프로그램이다. 해당 프로그램에서 사용할 노드는 한가지이다. 각 사원별 이름과 부하직원을 저장할 string vector을 가지는 Node 객체이다. 사용할 기능은 전체적으로 2개의 기능이 있다. 첫번째는 고용함수, 두번째는 해고함수이다.  

### (1)	hire(고용함수) Project3의 Organization.cpp참조
A가 B를 고용한다고 가정해보자. 우선 A가 트리내에 존재해야 하고, B가 존재하지 않아야 한다. 먼저, A와 B가 존재하는지 탐색한다. 여기서 쉬운 탐색을 위해 Organization객체 내에 사원들의 이름을 저장하기 위한 벡터(OrganizationTree.h의 people)를 하나 만들어 두었다.
A가 존재하고 B가 존재하지 않음을 확인 했으면, Root노드로부터 A의 위치를 탐색해나간다.
탐색하는과정은 DFS를 사용하였다. BFS와 DFS는 둘 다 성능은 비슷하지만 구현이 재귀함수를 이용한 DFS탐색이 쉽다고 생각했기 때문에 DFS로 설계 및 구현하였다.

### (2)	fire(해고함수) Project3 의 Organization.cpp참조
우선 A를 해고한다고 가정하자. 먼저 A가 Tree내에 존재하는지 탐색을 한다. 이는 위에서 언급된 hire함수에서의 과정과 동일하다. A가 존재 한다면 DFS로 위치를 탐색한 후 삭제 과정을 거친다.
해고되는 노드가 Root노드인 경우와 Root노드가 아닌 경우를 나누어서 연산을 한다. 해고된 뒤에 위치는 부하직원 노드의 가장 왼쪽 자식이 Root노드의 위치가 된다.
예시로 위의 사진에서 Stallings를 해고한다면 Stallings의 자리대신 Knuth가 오게 된다.
